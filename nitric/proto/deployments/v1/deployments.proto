syntax = "proto3";
package nitric.proto.deployments.v1;

//protoc plugin options for code generation
option go_package = "github.com/nitrictech/nitric/core/pkg/proto/deployments/v1;deploymentspb";
option java_package = "io.nitric.proto.deployments.v1";
option java_multiple_files = true;
option java_outer_classname = "Deployments";
option php_namespace = "Nitric\\Proto\\Deployments\\V1";
option csharp_namespace = "Nitric.Proto.Deployments.v1";

import "google/protobuf/struct.proto";
import "nitric/proto/resources/v1/resources.proto";
import "nitric/proto/storage/v1/storage.proto";

// The Nitric Deloyment Service contract
service Deployment {
    // Begins a new deployment
    // Server will stream updates back to the connected client
    // on the status of the deployment
    rpc Up (DeploymentUpRequest) returns (stream DeploymentUpEvent);
    // Tears down an existing deployment
    // Server will stream updates back to the connected client
    // on the status of the teardown
    rpc Down (DeploymentDownRequest) returns (stream DeploymentDownEvent);
}

message DeploymentUpRequest {
    // The spec to deploy
    Spec spec = 1;

    // A map of attributes related to the deploy request
    // this allows for adding project identifiers etc.
    google.protobuf.Struct attributes = 2;

    // A hint to the provider of the kind of output that the client can accept
    // This will allow provider developers to provider richer output back to clients.
    bool interactive = 3;
}

message DeploymentUpEvent {
    oneof content {
        string message = 1;
        ResourceUpdate update = 2;
        UpResult result = 3;
    }
}

enum ResourceDeploymentAction {
    // A new resource is being created
    CREATE = 0;
    // An existing resource is being updated
    UPDATE = 1;
    // An existing resource is being replaced
    REPLACE = 2;
    // No-op on the resource (it already exists and requires no changes)
    SAME = 3;
    // An existing resource is being deleted
    DELETE = 4;
}

enum ResourceDeploymentStatus {
    // The action hasn't started, usually due to a dependency
    PENDING = 0;
    // The action in currently in-flight, e.g. waiting for cloud provder to provision a resource
    IN_PROGRESS = 1;
    // The action has been applied successfully
    SUCCESS = 2;
    // The action has failed to be (completely) applied
    FAILED = 3;
}

/*

hello : service : created
| latest message goes here.
|- Container Image : created
|- ECR Repository : failed

*/

message ResourceUpdate {
    // The resource being updated, if this is nil the update applies to the stack
    nitric.proto.resources.v1.ResourceIdentifier id = 1;

    // The type of update being applied
    ResourceDeploymentAction action = 3;

    // The current status of the action being applied
    ResourceDeploymentStatus status = 4;

    // (optional) A globally unique identifier (scoped to the id above), used when Nitric Resources map 1:many in a cloud provider.
    // e.g. the container image repository for a service deployment.
    // This can also be set when id is nil above and it will imply a non-nitric resource that is necessary to deploy for a stack to operate 
    // e.g. an Azure StorageAccount
    string sub_resource = 5;

    // Additional information about the update
    string message = 6;
}

// Terminal message indicating deployment success
message UpResult {
    // Indicate the success status
    bool success = 1;

    
    oneof content {
        // Simple text output as result
        string Text = 2;
    }
}

message DeploymentDownRequest {
    // A map of attributes related to the deploy request
    // this allows for adding project identifiers etc.
    google.protobuf.Struct attributes = 1;

    // A hint to the provider of the kind of output that the client can accept
    // This will allow provider developers to provider richer output back to clients.
    bool interactive = 2;
}

message DeploymentDownEvent {
    oneof content {
        string message = 1;
        DownResult result = 2;
        ResourceUpdate update = 3;
    }
}

// Terminal message indicating deployment success
message DownResult {}

// An image source to be used for service deployment
message ImageSource {
    // URI of the docker image
    // TODO: May also need to provide auth information (although this should just be configured on the running client already)
    string uri = 1;
}

// A unit of service (i.e. function/container)
message Service {
    // Source of the service
    oneof source {
        // Container image as a service
        ImageSource image = 1;
        // Alternative sources could include 
        // - zipped code sources
        // - git/scm repository URIs
        
    }

    // Expected worker count for this service
    int32 workers = 10;
    // Configurable timeout for request handling
    int32 timeout = 11 [deprecated = true];
    // Configurable memory size for this instance
    int32 memory = 12 [deprecated = true];

    // A simple type property
    // describes the requested type of service that this should be
    // for this project, a provider can implement how this request is satisfied
    // in any way
    string type = 13;

    // Environment variables for this service
    map<string, string> env = 14; 
}

message Bucket {
    repeated BucketListener listeners = 1;
}

message BucketListener {
    nitric.proto.storage.v1.RegistrationRequest config = 1;
    oneof target {
        // The name of an service to target
        string service = 2;
    }
}


message Topic {
    repeated SubscriptionTarget subscriptions = 1;
}

message Queue {}

message KeyValueStore {

}

message Secret {
    
}

message SubscriptionTarget {
    oneof target {
        // The name of an service to target
        string service = 1;

        // Additional targets could potentially include
        // - HTTP/API Endpoints
        // - Queues
    }
}

message TopicSubscription {
    SubscriptionTarget target = 1;
}

message HttpTarget {
    oneof target {
        // The name of an service to target
        string service = 1;
    }
}

// A http resource
message Http {
    HttpTarget target = 1;
}

message Api {
    oneof document {
        // An OpenAPI document for deployment
        // This document will contain extensions that hint of services that should be targeted as part of the deployment
        string openapi = 1;
    }
}

// Declare a new websocket
message Websocket {
    // Target for handling new client connections
    WebsocketTarget connect_target = 1;
    // Target for handling client disconnections
    WebsocketTarget disconnect_target = 2;
    // Target for handling all other message types
    WebsocketTarget message_target = 3;
}

message WebsocketTarget {
    oneof target {
        // The name of an service to target
        string service = 1;

        // Additional targets could potentially include
        // - HTTP/API Endpoints
    }
}

message ScheduleTarget {
    oneof target {
        // The name of an service to target
        string service = 1;

        // Additional targets could potentially include
        // - HTTP/API Endpoints
    }
}

message Schedule {
 ScheduleTarget target = 1;

  oneof cadence {
    ScheduleEvery every = 10;
    ScheduleCron cron = 11;
  }
}

message ScheduleEvery {
    // rate string e.g. '5 minutes'. Value frequencies are 'minutes', 'hours', 'days'.
    string rate = 1;
}

message ScheduleCron {
    // standard unix cron expression
    string expression = 1;
}

message Resource {
    nitric.proto.resources.v1.ResourceIdentifier id = 1;

    oneof config {
        Service service = 10;
        Bucket bucket = 11;
        Topic topic = 12;
        Api api = 13;
        Policy policy = 14;
        Schedule schedule = 15;
        KeyValueStore key_value_store = 16;
        Secret secret = 17;
        Websocket websocket = 18;
        Http http = 19;
        Queue queue = 20;
    }
}

// This is already defined in the resource contracts...
// Need to determine if it's worth re-using
// unfortunately there are parts we don't want to duplicate, such as API config
message Policy {
    repeated Resource principals = 1;
    // TODO: Split out discrete action definitions from resources
    // Also need to allow custom action types as well
    // Should incorporate action re-use here...
    repeated nitric.proto.resources.v1.Action actions = 2;
    repeated Resource resources = 3;
}

message Spec {
    // list of resources to deploy
    repeated Resource resources = 1;
}
