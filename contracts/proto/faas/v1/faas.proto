syntax = "proto3";
package nitric.faas.v1;

// protoc plugin options for code generation
option go_package = "github.com/nitrictech/nitric/core/pkg/api/nitric/v1";
option java_package = "io.nitric.proto.faas.v1";
option java_multiple_files = true;
option java_outer_classname = "NitricFaas";
option php_namespace = "Nitric\\Proto\\Faas\\V1";
option csharp_namespace = "Nitric.Proto.Faas.v1";

// Service for streaming communication with gRPC FaaS implementations
service FaasService {
  // Begin streaming triggers/response to/from the membrane
  rpc TriggerStream (stream ClientMessage) returns (stream ServerMessage);
}

// Messages the client is able to send to the server
message ClientMessage {
  // Client message ID, used to pair requests/responses
  string id = 1;

  oneof content {
    // Client initialisation request
    // A worker will not be eligible for triggers
    // until it has identified itself
    InitRequest init_request = 2;

    // Client responsding with result of
    // a trigger
    TriggerResponse trigger_response = 3; 
  }
}

// Messages the server is able to send to the client
message ServerMessage {
  // Server message ID, used to pair requests/responses
  string id = 1;

  oneof content {
    // Server responding
    // with client configuration details to an
    // InitRequest
    InitResponse init_response = 2;

    // Server requesting client to
    // process a trigger
    TriggerRequest trigger_request = 3;
  }
}

message ApiWorkerScopes {
  repeated string scopes = 1;
}

message ApiWorkerOptions {
  // Apply security definitions to this operation
  map<string, ApiWorkerScopes> security = 1;
  // explicitly disable security for this endpoint
  // We need to do this as the default value of a repeated field
  // is always empty so there is no way of knowing if security is explicitly disabled
  bool security_disabled = 2;
}

message ApiWorker {
  string api = 1;
  string path = 2;
  repeated string methods = 3;
  ApiWorkerOptions options = 4;
}

message SubscriptionWorker {
  string topic = 1;
}

message ScheduleWorker {
  string key = 1;
  oneof cadence {
    ScheduleRate rate = 10;
    ScheduleCron cron = 11;
  }
}

message ScheduleRate {
  string rate = 1;
}

message ScheduleCron {
  string cron = 1;
}

// Notification Workers
enum BucketNotificationType {
  All = 0;
  Created = 1;
  Deleted = 2;
}

message HttpWorker {
  // The local port the server can be accessed on
  int32 port = 1;
}

message BucketNotificationWorker {
  string bucket = 1;
	BucketNotificationConfig config = 2;
}

message BucketNotificationConfig {
	BucketNotificationType notification_type = 1;
  // A notification filter is a prefix for a bucket object in which creations or deletions should trigger a notification:
  // e.g. Notification filter: /images/cat and Event Type: created, would trigger on creating /images/cat.png and /images/cat.jpg but not creating /cat.png
	string notification_prefix_filter = 2;
}

enum WebsocketEvent {
  // Specialised Event for handling new client connections
  Connect = 0;
  // Specialised Event for handling existing client connections
  Disconnect = 1;
  // All other types of events are messages
  Message = 2;
}

message WebsocketWorker {
  // The nitric name of the socket that this worker listens on
  string socket = 1;
  // The type of event that this worker handles
  WebsocketEvent event = 2;
}

// Generic catch all worker (XXX: Do we need this for backwards compatibility?)
//message FunctionWorker {

//}

// InitRequest - Identifies a worker as ready to recieve triggers
// This message will contain information on the type of triggers that
// a worker is capable of handling
message InitRequest {
  // The type of worker we are registering
  oneof Worker {
    ApiWorker api = 10;
    SubscriptionWorker subscription = 11;
    ScheduleWorker schedule = 12;
    BucketNotificationWorker bucket_notification = 13;
    WebsocketWorker websocket = 14;
    HttpWorker http_worker = 15;
  }
}

// Placeholder message
message InitResponse {}

message TraceContext {
  map<string, string> values = 1;
}

// The server has a trigger for the client to handle
message TriggerRequest {
  // The data in the trigger
  bytes data = 1;

  // Should we supply a mime type for the data?
  // Or rely on context?
  string mime_type = 2;

  // TraceInformation from the membrane
  // Allows tying traces from external triggers (e.g. HttpRequests)
  // into each event request/response pair of the Bidirectional stream.
  // which cannot be facilitated by OOTB stream interceptors from OTEL.
  TraceContext trace_context = 10;

  // The context of the trigger
  oneof context {
    HttpTriggerContext http = 3;
    TopicTriggerContext topic = 4;
    NotificationTriggerContext notification = 5;
    WebsocketTriggerContext websocket = 6;
  }
}

message HeaderValue {
  repeated string value = 1;
}

message QueryValue {
  repeated string value = 1;
}

message HttpTriggerContext {

  // The request method
  string method = 1;

  // The path of the request
  string path = 2;

  // The old request headers (preserving for backwards compatibility)
  // TODO: Remove in 1.0
  map<string, string> headers_old = 3 [deprecated=true];
  
  // The old query params (preserving for backwards compatibility)
  // TODO: Remove in 1.0
  map<string, string> query_params_old = 4  [deprecated=true];

  // HTTP request headers
  map<string, HeaderValue> headers = 5;

  // HTTP Query params
  map<string, QueryValue> query_params = 6;

  // HTTP Path parameters
  map<string, string> path_params = 7;
}

message TopicTriggerContext {
  // The topic the message was published for
  string topic = 1;

  // TODO: Add the event ID to the trigger context here got transactional outbox?
}

message BucketNotification {
  string key = 1;
  BucketNotificationType type = 2;
}

message NotificationTriggerContext {
  string source = 1;
  
  // Now we don't need to specify a type enum, the specific contents/type comes in a single field of the context.
  oneof notification {
     BucketNotification bucket = 10;
  }
}

message WebsocketTriggerContext {
  // The nitric name of the socket that this worker listens on
  string socket = 1;

  // The type of websocket event
  WebsocketEvent event = 2;

  // The connection this trigger came from
  string connectionId = 3;

  // The query params available in the connection request
  map<string, QueryValue> query_params = 6;
}

// The worker has successfully processed a trigger
message TriggerResponse {
  // The data returned in the response
  bytes data = 1;

  // The context of the request response
  // Typically this will be one to one with the Trigger Context
  // i.e. if you receive http context you may return http context
  oneof context {
    // response to a http request
    HttpResponseContext http = 10;
    // response to a topic trigger
    TopicResponseContext topic = 11;
    // response to a notification trigger
    NotificationResponseContext notification = 12;

    WebsocketResponseContext websocket = 13;
  }
}

// Specific HttpResponse message
// Note this does not have to be handled by the
// User at all but they will have the option of control
// If they choose...
message HttpResponseContext {
  // Old HTTP response headers (deprecated)
  // TODO: Remove in 1.0
  map<string, string> headers_old = 1 [deprecated=true];

  // The HTTP status of the request
  int32 status = 2;

  // HTTP response headers
  map<string, HeaderValue> headers = 3;
}

// Specific event response message
// We do not accept responses for events
// only whether or not they were successfully processed
message TopicResponseContext {
  // Success status of the handled event
  bool success = 1;
}

message NotificationResponseContext {
	bool success = 1;
}

message WebsocketResponseContext {
  // There aren't really responses here, instead we need to provide a runtime
  // API for responding back and emitting/broadcasting on the websocket from the server
  bool success = 1;
}